import asyncio
import aiohttp
import ccxt
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging
from typing import List, Dict, Tuple
import time
import sys


class CryptoShakeoutMonitor:
    def __init__(self,
                 exchange_id: str = 'binance',
                 min_volume: float = 50000,
                 check_interval: int = 3600,
                 mode: str = 'TESTING'):  # TESTING, SWING_TRADING, –∏–ª–∏ INTRADAY_TRADING

        # Updated timeframes with proper periods
        self.timeframes = {
            'SWING_TRADING': {'trend': '1w', 'entry': '1d', 'trend_limit': 52},  # 1 year of weekly data
            'INTRADAY_TRADING': {'trend': '1d', 'entry': '1h', 'trend_limit': 180},  # 6 months of daily data
            'TESTING': {'trend': '1d', 'entry': '1h', 'trend_limit': 180}  # 6 months for testing
        }
        self.current_mode = mode

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('crypto_monitor.log', encoding='utf-8'),
                logging.StreamHandler(sys.stdout)  # Use stdout for console output
            ]
        )
        # Force console encoding to UTF-8
        if sys.platform.startswith('win'):
            import codecs
            sys.stdout.reconfigure(encoding='utf-8')
            sys.stderr.reconfigure(encoding='utf-8')

        self.logger = logging.getLogger(__name__)

        self.exchange = getattr(ccxt, exchange_id)()
        self.min_volume = min_volume
        self.check_interval = check_interval

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """–†–∞—Å—á–µ—Ç MACD –∏ Elder's indicators"""
        try:
            # MACD(12,26,9)
            df['ema12'] = df['close'].ewm(span=12, adjust=False).mean()
            df['ema26'] = df['close'].ewm(span=26, adjust=False).mean()
            df['macd'] = df['ema12'] - df['ema26']
            df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()

            # Elder's favorites settings
            df['center_ema'] = df['close'].ewm(span=26, adjust=False).mean()
            df['short_ema'] = df['close'].ewm(span=12, adjust=False).mean()

            return df
        except Exception as e:
            self.logger.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤: {str(e)}')
            return df

    def analyze_trend(self, symbol: str) -> str:
        """–ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞ –Ω–∞ —Å—Ç–∞—Ä—à–µ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º EMA –∏ –±–æ–ª–µ–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞"""
        try:
            timeframe = self.timeframes[self.current_mode]['trend']
            limit = self.timeframes[self.current_mode]['trend_limit']
            self.logger.info(f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç—Ä–µ–Ω–¥ {symbol} –Ω–∞ —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ {timeframe} –∑–∞ –ø–µ—Ä–∏–æ–¥ {limit}")

            ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

            # Calculate Smart Vision EMA 20
            df['ema20'] = df['close'].ewm(span=20, adjust=False).mean()
            
            # Get last 20 periods for trend analysis
            last_20 = df.tail(20)
            
            # Calculate trend based on EMA and price action
            price_above_ema = last_20['close'].iloc[-1] > last_20['ema20'].iloc[-1]
            ema_slope = (last_20['ema20'].iloc[-1] - last_20['ema20'].iloc[0]) / len(last_20)
            
            # Check for higher highs and higher lows in the recent period
            recent_highs = last_20['high'].values
            recent_lows = last_20['low'].values
            
            # Calculate trends using local maxima and minima
            higher_highs = np.all(np.diff([h for h in recent_highs if h == np.maximum.accumulate(recent_highs)[recent_highs.tolist().index(h)]]) > 0)
            higher_lows = np.all(np.diff([l for l in recent_lows if l == np.minimum.accumulate(recent_lows)[recent_lows.tolist().index(l)]]) > 0)
            
            lower_highs = np.all(np.diff([h for h in recent_highs if h == np.maximum.accumulate(recent_highs)[::-1][recent_highs.tolist()[::-1].index(h)]]) < 0)
            lower_lows = np.all(np.diff([l for l in recent_lows if l == np.minimum.accumulate(recent_lows)[::-1][recent_lows.tolist()[::-1].index(l)]]) < 0)

            self.logger.info(f"""
            Trend Analysis Results:
            Price above EMA20: {price_above_ema}
            EMA Slope: {ema_slope}
            Higher Highs: {higher_highs}
            Higher Lows: {higher_lows}
            Lower Highs: {lower_highs}
            Lower Lows: {lower_lows}
            Last Price: {last_20['close'].iloc[-1]}
            """)

            # Determine trend with more flexible conditions
            if price_above_ema and ema_slope > 0:
                if higher_highs or higher_lows:
                    self.logger.info("–û–ø—Ä–µ–¥–µ–ª–µ–Ω Strong BULLISH —Ç—Ä–µ–Ω–¥")
                    return 'bullish'
                self.logger.info("–û–ø—Ä–µ–¥–µ–ª–µ–Ω BULLISH —Ç—Ä–µ–Ω–¥ (based on EMA)")
                return 'bullish'
            elif not price_above_ema and ema_slope < 0:
                if lower_highs or lower_lows:
                    self.logger.info("–û–ø—Ä–µ–¥–µ–ª–µ–Ω Strong BEARISH —Ç—Ä–µ–Ω–¥")
                    return 'bearish'
                self.logger.info("–û–ø—Ä–µ–¥–µ–ª–µ–Ω BEARISH —Ç—Ä–µ–Ω–¥ (based on EMA)")
                return 'bearish'

            self.logger.info("–û–ø—Ä–µ–¥–µ–ª–µ–Ω NEUTRAL —Ç—Ä–µ–Ω–¥")
            return 'neutral'

        except Exception as e:
            self.logger.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —Ç—Ä–µ–Ω–¥–∞: {str(e)}')
            self.logger.exception("–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏:")
            return 'neutral'

    def detect_shakeout(self, df: pd.DataFrame, trend: str) -> Dict:
        """
        –ò—â–µ—Ç —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –≤ –ø–æ–∑–∏—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ–±–æ—è –∑–æ–Ω—ã —Ü–µ–Ω–Ω–æ—Å—Ç–∏ (EMA) –ø–æ—Å–ª–µ –æ—Ç–∫–∞—Ç–∞.
        
        Args:
            df: DataFrame —Å–æ —Å–≤–µ—á–∞–º–∏ (OHLCV –¥–∞–Ω–Ω—ã–µ)
            trend: –¢–µ–∫—É—â–∏–π —Ç—Ä–µ–Ω–¥ ('bullish' - –≤–æ—Å—Ö–æ–¥—è—â–∏–π, 'bearish' - –Ω–∏—Å—Ö–æ–¥—è—â–∏–π)
        
        Returns:
            Dict: –°–ª–æ–≤–∞—Ä—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Å–∏–≥–Ω–∞–ª–µ
        """
        try:
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã (MACD –∏ EMA)
            df = self.calculate_indicators(df)
            
            # –ë–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—É—é —Å–≤–µ—á–∫—É
            last_candle = df.iloc[-1]
            
            # –°–æ–∑–¥–∞—ë–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏–≥–Ω–∞–ª–µ
            signal = {
                'is_signal': False,            # –§–ª–∞–≥ –Ω–∞–ª–∏—á–∏—è —Å–∏–≥–Ω–∞–ª–∞
                'type': None,                  # –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞ (LONG –∏–ª–∏ SHORT)
                'price': last_candle['close'], # –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
                'macd_value': last_candle['macd'],      # –ó–Ω–∞—á–µ–Ω–∏–µ MACD
                'ema_value': last_candle['center_ema']  # –ó–Ω–∞—á–µ–Ω–∏–µ EMA (–∑–æ–Ω–∞ —Ü–µ–Ω–Ω–æ—Å—Ç–∏)
            }

            # –°—á–∏—Ç–∞–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ EMA
            price_to_ema = last_candle['close'] / last_candle['center_ema']

            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            self.logger.info(f"""
            –ê–Ω–∞–ª–∏–∑ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏:
            - –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {last_candle['close']:.2f}
            - EMA (–∑–æ–Ω–∞ —Ü–µ–Ω–Ω–æ—Å—Ç–∏): {last_candle['center_ema']:.2f}
            - MACD: {last_candle['macd']:.6f}
            - –¢—Ä–µ–Ω–¥: {trend}
            - –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ü–µ–Ω–∞/EMA: {price_to_ema:.4f}
            """)

            # –õ–û–ì–ò–ö–ê –î–õ–Ø –ë–´–ß–¨–ï–ì–û –¢–†–ï–ù–î–ê (LONG)
            if trend == 'bullish':
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è –≤—Ö–æ–¥–∞ –≤ LONG:
                # 1. –¶–µ–Ω–∞ –æ–∫–æ–ª–æ –∏–ª–∏ –Ω–∏–∂–µ EMA (–æ—Ç–∫–∞—Ç –∑–∞–≤–µ—Ä—à–∏–ª—Å—è)
                # 2. MACD –≤ –∫—Ä–∞—Å–Ω–æ–π –∑–æ–Ω–µ (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–∫–∞—Ç–∞)
                if price_to_ema <= 1.02 and last_candle['macd'] < 0:
                    if self.is_new_signal(last_candle['close'], last_candle['center_ema'], last_candle['macd']):
                        self.logger.info(f"""
                        üéØ –ù–∞–π–¥–µ–Ω–∞ —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ (LONG):
                        - –¶–µ–Ω–∞ –æ—Ç–∫–∞—Ç–∏–ª–∞—Å—å –∫ –∑–æ–Ω–µ —Ü–µ–Ω–Ω–æ—Å—Ç–∏
                        - –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ü–µ–Ω–∞/EMA: {price_to_ema:.4f}
                        - MACD –≤ –∫—Ä–∞—Å–Ω–æ–π –∑–æ–Ω–µ: {last_candle['macd']:.6f}
                        """)
                        signal['is_signal'] = True
                        signal['type'] = 'LONG'
                        self.update_last_signal(last_candle['close'], last_candle['center_ema'], 
                                             last_candle['macd'], 'LONG')

            # –õ–û–ì–ò–ö–ê –î–õ–Ø –ú–ï–î–í–ï–ñ–¨–ï–ì–û –¢–†–ï–ù–î–ê (SHORT)
            elif trend == 'bearish':
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è –≤—Ö–æ–¥–∞ –≤ SHORT:
                # 1. –¶–µ–Ω–∞ –æ–∫–æ–ª–æ –∏–ª–∏ –≤—ã—à–µ EMA (–æ—Ç–∫–∞—Ç –∑–∞–≤–µ—Ä—à–∏–ª—Å—è)
                # 2. MACD –≤ –∑–µ–ª—ë–Ω–æ–π –∑–æ–Ω–µ (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–∫–∞—Ç–∞)
                if price_to_ema >= 0.98 and last_candle['macd'] > 0:
                    if self.is_new_signal(last_candle['close'], last_candle['center_ema'], last_candle['macd']):
                        self.logger.info(f"""
                        üéØ –ù–∞–π–¥–µ–Ω–∞ —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ (SHORT):
                        - –¶–µ–Ω–∞ –ø–æ–¥–Ω—è–ª–∞—Å—å –∫ –∑–æ–Ω–µ —Ü–µ–Ω–Ω–æ—Å—Ç–∏
                        - –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ü–µ–Ω–∞/EMA: {price_to_ema:.4f}
                        - MACD –≤ –∑–µ–ª—ë–Ω–æ–π –∑–æ–Ω–µ: {last_candle['macd']:.6f}
                        """)
                        signal['is_signal'] = True
                        signal['type'] = 'SHORT'
                        self.update_last_signal(last_candle['close'], last_candle['center_ema'], 
                                             last_candle['macd'], 'SHORT')

            return signal

        except Exception as e:
            self.logger.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –≤—Å—Ç—Ä—è—Å–∫–∏: {str(e)}')
            return {'is_signal': False, 'type': None, 'price': 0, 'macd_value': 0, 'ema_value': 0}

    async def run_forever(self, alert_callback=None):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        self.logger.info('–ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤—Å—Ç—Ä—è—Å–æ–∫...')

        while True:
            try:
                # 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç—Ä–µ–Ω–¥ –Ω–∞ —Å—Ç–∞—Ä—à–µ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ
                trend = self.analyze_trend('BTC/USDT')
                self.logger.info(f'–¢–µ–∫—É—â–∏–π —Ç—Ä–µ–Ω–¥ BTC: {trend}')

                if trend == 'neutral':
                    self.logger.info('–¢—Ä–µ–Ω–¥ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑')
                    time.sleep(self.check_interval)
                    continue

                # 2. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –º–ª–∞–¥—à–∏–π —Ç–∞–π–º—Ñ—Ä–µ–π–º
                timeframe = self.timeframes[self.current_mode]['entry']
                ohlcv = self.exchange.fetch_ohlcv('BTC/USDT', timeframe, limit=100)
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

                # 3. –ò—â–µ–º –≤—Å—Ç—Ä—è—Å–∫—É
                signal = self.detect_shakeout(df, trend)

                if signal['is_signal']:
                    message = f"""
    üö® –í—Å—Ç—Ä—è—Å–∫–∞ –Ω–∞ BTC!
    üìà –¢—Ä–µ–Ω–¥: {trend}
    üí∞ –¶–µ–Ω–∞: {signal['price']:.2f}
    üìä –¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞: {'üü¢ LONG' if signal['type'] == 'LONG' else 'üî¥ SHORT'}
    ‚è∞ –í—Ä–µ–º—è: {datetime.now()}

    üîç MACD: {signal['macd_value']:.6f}
    """
                    if alert_callback:
                        await alert_callback(message)
                        self.logger.info(f'–û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Å–∏–≥–Ω–∞–ª –æ –≤—Å—Ç—Ä—è—Å–∫–µ: {signal["type"]}')

                time.sleep(self.check_interval)

            except Exception as e:
                self.logger.error(f'–û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {str(e)}')
                time.sleep(60)


async def send_telegram_alert(message):
    async with aiohttp.ClientSession() as session:
        async with session.post("http://localhost:8000/send_message",
                                json={"text": message}) as response:
            await response.json()


async def main():
    monitor = CryptoShakeoutMonitor(
        exchange_id='binance',
        min_volume=50000,
        check_interval=120,
        mode='TESTING'  # –î–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    )
    await monitor.run_forever(alert_callback=send_telegram_alert)


if __name__ == "__main__":
    asyncio.run(main())